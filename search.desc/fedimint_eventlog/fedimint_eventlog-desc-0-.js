searchState.loadedDescShard("fedimint_eventlog", 0, "Client Event Log\nDB prefixes hardcoded for use of the event log …\nOrdered, contiguous ID space, which is easy for event log …\nStruct used for processing log entries after they have …\nHelper struct for storing computed data about outgoing and …\nAn counter that resets on every restart, that guarantees …\nA self-allocated ID that is mostly ordered\nCombines this <code>StructuredPaymentEvents</code> with the <code>other</code> …\nFilters the <code>PersistedLogEntries</code> by the <code>EventKind</code> and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRead a part of the event log.\nNext <code>EventLogId</code> to use for new ordered events.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nJoins two sets of events on a predicate.\nType/kind of the event\nLog an event log event\nTo prevent accidental conflicts between <code>kind</code>s, a module …\nEvent-kind specific payload, typically encoded as a json …\nThe code that handles new unordered events and rewriters …\nSorts this <code>StructuredPaymentEvents</code> by sorting all of the …\nTimestamp in microseconds after unix epoch")