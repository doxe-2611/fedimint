searchState.loadedDescShard("hkdf", 0, "This crate implements the RFC5869 hash based key …\nTrait which applies to hashes of all types.\nThe byte array that represents the hash internally.\nFlag indicating whether user-visible serializations of …\nA hashing engine which bytes can be serialized into. It is …\nImplements the RFC5869 hash based key derivation function …\nLength of the hash, in bytes.\nReturns an all zero hash.\nReturns a reference to the underlying byte array.\nRun HKDF-expand to generate new key material\nRun HKDF-expand to generate new key material with …\nConstructs a new engine.\nReturns the argument unchanged.\nConstructs a hash from the underlying byte array.\nProduces a hash from the current state of a given engine.\nConstruct the HKDF from a pseudo random key that has the …\nCopies a byte slice into a hash object.\nHashes some bytes.\nHashes all the byte slices retrieved from the iterator …\nCalls <code>U::from(self)</code>.\nRun HKDF-extract and keep the resulting pseudo random key …\nReturns the underlying byte array.\nOutput of the Bitcoin HASH160 hash function. …\nOutput of the RIPEMD160 hash function.\nOutput of the SHA1 hash function.\nOutput of the SHA256 hash function.\nOutput of the SHA256d hash function.\nOutput of the SHA512 hash function.\nOutput of the SipHash24 hash function.\nReturns the (little endian) 64-bit integer representation …\nComputes hash from <code>bytes</code> in <code>const</code> context.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nZero cost conversion between a fixed length byte array …\nProduces a hash as <code>u64</code> from the current state of a given …\nCreates a hash from its (little endian) 64-bit integer …\nIterate the sha256 algorithm to turn a sha256 hash into a …\nHashes the given data directly to u64 with an engine with …\nHashes the given data with an engine with the provided …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")